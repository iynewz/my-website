---
tags:
  - C++
  - Move 
---

# 13.6 Move

## Rvalue References 右值引用
    
判断表达式是否是左值，有一个简单的办法，就是看看能否取它的地址，能取地址的就是左值。左值享有内存一个不变地址。

>A useful heuristic to determine whether an expression is an lvalue is to ask if you can  take its address. If you can, it typically is. If you can’t, it’s usually an rvalue.
    
右值引用（&&）的作用：区分“即将被销毁的对象”，从而安全、高效地“移动”资源，而不是拷贝。

为什么我们要在这里学 Rvalue References 的概念？和 move 有什么关系？从逻辑上，右值引用和 move 的关系是：为了提高效率，提出了 move 这一语义, 为了安全地移动资源，C++ 才不得不引入右值引用。


### C++11 之前的问题：语言无法表达“对象即将死亡”

在 C++11 之前，语言没有能力表达“临时对象”的概念，哪怕一个对象马上就要被销毁了，语言层面也无法区分。

```C++
Array makeArray() {
    Array a(1000000);
    return a;
}
```

a 在 return 之后就会被析构，但在 C++11 之前，编译器只能看到：`Array(const Array& temp_array);` 即使对象马上就要死了，也只能深拷贝，这对管理大资源的类型来说代价非常高。

于是有人提出用这种方式解决：

```C++
Array(const Array& temp_array, bool move) {
    data_ = temp_array.data_;
    size_ = temp_array.size_;
    temp_array.data_ = nullptr; //断开源对象与资源的关系，这样在 temp_array 析构时，就不会发生 double free。
}
```

这段代码意图是，既然后续不再需要源对象（`temp_array`）的资源，那么把源对象的资源移动过来，再清空源对象就行了。 

Array 的资源，本质就是一个指向一块动态分配堆内存的指针（`temp_array.data_`）、一个表示大小的 int. 那么把指针和大小复制出来，再断开源对象与资源的关系，就可以了。

虽然这个方案在“移动指针、大小”的思路上是正确的，但这种写法仍然是错误方案。在 C++11 之前，如果一个构造函数要“接受一个已有对象”，那么它的参数“只能”是 `const T&`。这个方案最大的错误是 `const Array&` 保证不修改这个对象的状态，但 const 的语义在 `temp_array.data_ = nullptr;` 这一步被破坏了。（还有其他不够好的地方，比如第二个 bool 参数是人为加的，不优雅）

### 右值引用的引入

于是，C++11 增加了右值引用：`T&&`  使用 std::move 可以将左值显式转换为右值引用。

```C++
Array b = std::move(a);
```

Array&& 在语言层保证 a 在这之后不再被使用。

目前，我们理解了，没有右值引用，无法区分“还要用的对象”和“马上销毁的对象”，move 是不可能被正确实现的。

## 手动实现 Move 的原理

TODO