---
tags:
  - C++
  - Dynamic Memory
---

# 13. Copy Control

Copy control ä¸æ­¢ç®¡ç† copy, è¿˜ç®¡ç† move å’Œ destroyã€‚

Copy control ä¸“é—¨æŒ‡è´Ÿè´£å¯¹è±¡èµ„æºç®¡ç†ä¸ç”Ÿå‘½å‘¨æœŸçš„äº”ä¸ªç‰¹æ®Šæˆå‘˜å‡½æ•°ï¼šcopy constructor, move constructor, copy-assignment operator, move-assignment operator, å’Œ destructorã€‚

## The Copy Constructor

### ä»€ä¹ˆæ˜¯ Copy Constructorï¼Ÿ

Copy constructor æ˜¯ä¸€ç§æ„é€ å‡½æ•°ï¼Œç”¨åŒç±»å‹çš„å¦ä¸€ä¸ªå¯¹è±¡æ¥åˆå§‹åŒ–æ–°å¯¹è±¡ã€‚

copy constructor çš„ç¬¬ä¸€ä¸ªå‚æ•°å¿…é¡»æ˜¯å¯¹åŒç±»å¯¹è±¡çš„å¼•ç”¨ï¼š

```cpp
ClassName(const ClassName &);
```

### ä»€ä¹ˆæ—¶å€™ä¼šç”¨åˆ° copy initializationï¼Ÿ

1. **ç”¨ä¸€ä¸ªå¯¹è±¡åˆå§‹åŒ–å¦ä¸€ä¸ªå¯¹è±¡**

    ```cpp
    string s1 = "hello";  // å¦‚æœæ˜¯ direct initializationï¼šstring s1("hello");
    ```

2. **å½¢å‚ä¸æ˜¯å¼•ç”¨ï¼Œä¼šè§¦å‘ copy initialization**

    ```cpp
    void foo(string s) { }  // s ä¸æ˜¯å¼•ç”¨ â†’ å¿…é¡»è¿›è¡Œ copy initialization

    int main() {
        string a = "hi";
        foo(a);  // copy initializationï¼ˆa ç”¨æ¥åˆå§‹åŒ– sï¼‰
    }
    ```

3. **è¿”å›ä¸€ä¸ªå¯¹è±¡æ—¶ï¼ˆä¸æ˜¯å¼•ç”¨æˆ–æŒ‡é’ˆï¼‰ï¼Œä¹Ÿéœ€è¦ç”¨ copy constructor æ„é€ è¿”å›å€¼å¯¹è±¡**

    ```cpp
    string bar() {
        string s = "world";
        return s;   // copy initialization ç”¨ s åˆå§‹åŒ–è¿”å›å€¼å¯¹è±¡
    }
    ```

4. **å¤§å¤šæ•° STL å®¹å™¨æ“ä½œæ’å…¥å·²æœ‰å¯¹è±¡æ—¶**

    ```cpp
    vector<string> v;
    string a = "hi";

    v.push_back(a);           // copy constructor
    v.insert(v.begin(), a);   // copy constructor
    ```

5. **åˆ›å»ºä¸´æ—¶å¯¹è±¡æ¥æ»¡è¶³å‚æ•°ç±»å‹**

    ```cpp
    void f(string);

    f("hello");
    ```

### ä»€ä¹ˆæ—¶å€™ä¼šéšå¼ç”Ÿæˆ copy constructorï¼Ÿ

å¦‚æœç±»çš„æ‰€æœ‰æˆå‘˜éƒ½å¯æ‹·è´ï¼Œç¼–è¯‘å™¨è‡ªåŠ¨ç”Ÿæˆä¸€ä¸ª memberwise çš„æ‹·è´æ„é€ å‡½æ•°ï¼Œå®ƒçš„è¡Œä¸ºæ˜¯ï¼šæŒ‰ç±»ä¸­æˆå‘˜å‡ºç°çš„é¡ºåºï¼Œæˆå‘˜é€ä¸ªæ‹·è´ï¼Œæ¯ä¸ªé static æˆå‘˜ç”¨å®ƒè‡ªå·±çš„æ‹·è´è§„åˆ™ã€‚

å³ä½¿ç¼–è¯‘å™¨å¯èƒ½è·³è¿‡ copy/move constructorï¼Œcopy/move constructor æœ¬èº«ä»å¿…é¡»åˆæ³•ï¼ˆå­˜åœ¨å¹¶ä¸”å¯è®¿é—®ï¼‰ã€‚

### ä»€ä¹ˆæ—¶å€™ä¸ä¼šè‡ªåŠ¨ç”Ÿæˆï¼Ÿ

å¦‚æœæŸä¸ªæˆå‘˜ä¸å¯æ‹·è´ï¼Œæ•´ä¸ªç±»çš„æ‹·è´æ„é€ å‡½æ•°ä¼šè¢«ç¦æ­¢ã€‚

explicit æ„é€ å‡½æ•°ç¦æ­¢éšå¼è½¬æ¢ã€‚


???+ note "Exercise 13.5: Implement the copy constructor"

    ```cpp
    class HasPtr {
    public:
        // æ„é€ å‡½æ•°
        HasPtr(const std::string &s = std::string())
            : ps(new std::string(s)), i(0) { }

        // copy constructor
        HasPtr(const HasPtr &rhs)
            : ps(new std::string(*rhs.ps)), // deep copy
            i(rhs.i)
        { }

    private:
        std::string *ps;
        int i;
    };
    ```

## The Copy-Assignment Operator

Copy-assignment operator æ˜¯å¯¹è±¡èµ‹å€¼æ—¶è°ƒç”¨çš„æˆå‘˜å‡½æ•°ï¼Œé»˜è®¤æŒ‰æˆå‘˜é€ä¸ªèµ‹å€¼ï¼Œé€šå¸¸è¿”å›å·¦æ“ä½œæ•°çš„å¼•ç”¨ä»¥æ”¯æŒé“¾å¼èµ‹å€¼ã€‚

```cpp
class Foo {
public:
    Foo& operator=(const Foo&);
};
```

å¦‚æœæ²¡æœ‰è‡ªå·±å®šä¹‰ï¼Œç¼–è¯‘å™¨ä¼šåˆæˆä¸€ä¸ª synthesized copy-assignment operatorï¼Œé€ä¸ªæˆå‘˜èµ‹å€¼ï¼Œç±»ä¼¼ copy constructorï¼Œä½†ä½œç”¨å¯¹è±¡æ˜¯å·²å­˜åœ¨å¯¹è±¡ã€‚

## The Destructor

æ„é€ å‡½æ•°åˆ†é…æˆ–åˆå§‹åŒ–èµ„æºï¼Œææ„å‡½æ•°è´Ÿè´£é”€æ¯å¯¹è±¡é‡Šæ”¾èµ„æºã€‚ææ„å‡½æ•°æ²¡æœ‰å‚æ•°ï¼Œä¹Ÿæ²¡æœ‰è¿”å›å€¼ã€‚

```cpp
class Foo { 
public:  
    ~Foo(); 
};
```

* æ²¡å†™ææ„å‡½æ•° â†’ ç¼–è¯‘å™¨åˆæˆé»˜è®¤ææ„å‡½æ•°ã€‚
* ææ„é¡ºåºï¼šå…ˆæ‰§è¡Œå‡½æ•°ä½“ï¼Œç„¶åæŒ‰ä¸åˆå§‹åŒ–ç›¸åé¡ºåºé”€æ¯æˆå‘˜ã€‚

### ææ„å‡½æ•°ä»€ä¹ˆæ—¶å€™è¢«è°ƒç”¨ï¼Ÿ

å¾ˆå¤šæ™®é€šç±»å‹ï¼ˆå±€éƒ¨å˜é‡ã€STL å¯¹è±¡ã€æ™ºèƒ½æŒ‡é’ˆï¼‰å†…éƒ¨è‡ªå·±ç®¡ç†å†…å­˜ï¼ˆRAIIï¼‰ï¼Œæ¯”å¦‚ï¼š

```cpp
{
    std::string s = "hello";  // å±€éƒ¨å˜é‡
} // ç¦»å¼€ä½œç”¨åŸŸ â†’ è‡ªåŠ¨è°ƒç”¨ s çš„ææ„å‡½æ•°
```

ä½†æ˜¯å¯¹äºæ‰‹åŠ¨ç®¡ç†èµ„æºçš„ç±»ï¼Œå¦‚æœä¸å†™ææ„å‡½æ•°ï¼Œè¿™äº›èµ„æºä¸ä¼šè‡ªåŠ¨é‡Šæ”¾ï¼Œå°±ä¼šæ³„æ¼ï¼š

```cpp
class HasPtr {
    std::string *ps;
public:
    HasPtr(const std::string &s = "") : ps(new std::string(s)) {}
    ~HasPtr() { delete ps; }  // å¿…é¡»å†™ææ„å‡½æ•°é‡Šæ”¾å†…å­˜
};
```

### æ³¨æ„

1. å¼•ç”¨ç¦»å¼€ä½œç”¨åŸŸä¸ä¼šè§¦å‘ææ„å‡½æ•°ã€‚
ä¸¾ä¾‹ï¼š
    ```cpp
    {
        std::string s = "hello";  // å®é™…å¯¹è±¡
        std::string &r = s;       // r æ˜¯ s çš„å¼•ç”¨
    } // r ç¦»å¼€ä½œç”¨åŸŸ
    ```
    - r ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œåªæ˜¯å¼•ç”¨å˜é‡è¢«é”€æ¯ï¼ˆå…¶å®å¼•ç”¨æœ¬èº«åªæ˜¯åˆ«åï¼Œæ²¡æœ‰å†…å­˜éœ€è¦é‡Šæ”¾ï¼‰
    - s çš„ææ„å‡½æ•°ä¼šåœ¨ä½œç”¨åŸŸç»“æŸæ—¶è‡ªåŠ¨è°ƒç”¨

2. æŒ‡é’ˆå˜é‡ï¼ˆé™¤äº†æ™ºèƒ½æŒ‡é’ˆä»¥å¤–ï¼‰ç¦»å¼€ä½œç”¨åŸŸï¼Œåªé”€æ¯æŒ‡é’ˆæœ¬èº«ï¼ˆå³å­˜å‚¨åœ°å€çš„å†…å­˜ï¼‰ï¼ŒæŒ‡é’ˆæŒ‡å‘çš„å¯¹è±¡çš„ææ„å‡½æ•°ä¸ä¼šè‡ªåŠ¨è°ƒç”¨ã€‚
    ```cpp
    {
        std::string *p = new std::string("world");
    } // p ç¦»å¼€ä½œç”¨åŸŸ
    ```
    ```cpp
    {
        std::string *p = new std::string("world");
        delete p; // æ‰‹åŠ¨è§¦å‘ *p çš„ææ„å‡½æ•°
    }
    ```



???+ note "Exercise 13.3"

    ```cpp
    #include <iostream>
    struct X {
        X() { std::cout << "X()" << std::endl; }
        X(const X&) { std::cout << "X(const X&)" << std::endl; }
        X& operator=(const X&) { 
            std::cout << "operator=" << std::endl; 
            return *this; 
        }
        ~X() { std::cout << "~X()" << std::endl; }
    };

    int main() {
        X a;          // X()
        X b = a;      // X(const X&)
        X c;          
        c = b;        // operator=
        
        X *p = new X; // X()
        delete p;     // ~X()
        
        X arr[2];     // X() X()
    }
    ```



## The Rule of Three/Five

### 1. Classes That Need Destructors Need Copy and Assignment

è¿™æ®µä»£ç æœ‰ä»€ä¹ˆé—®é¢˜ï¼Ÿ

```cpp
class HasPtr {
public:
    HasPtr(const std::string &s = std::string())
        : ps(new std::string(s)), i(0) { }
    ~HasPtr() { delete ps; }  // WRONG: éœ€è¦ copy constructor å’Œ copy-assignment operator
private:
    std::string *ps;
    int i;
};
```

æ²¡æœ‰è‡ªå®šä¹‰çš„ copy constructer å’Œ copy assignment operator. 

ç¼–è¯‘å™¨ä¼šç”Ÿæˆ synthesized versions. è¿™æ ·ä¼šæœ‰ä»€ä¹ˆé—®é¢˜ï¼Ÿ

ç¼–è¯‘å™¨é»˜è®¤ç”Ÿæˆçš„æ‹·è´æ„é€ å‡½æ•°åšçš„äº‹æƒ…ç­‰ä»·äºï¼š

```cpp
HasPtr(const HasPtr &orig) 
    : ps(orig.ps), i(orig.i) { }
```
æ³¨æ„ï¼šps åªæ˜¯æ‹·è´äº†æŒ‡é’ˆçš„å€¼ï¼Œå¹¶æ²¡æœ‰æ‹·è´ std::string çš„å†…å®¹ã€‚

å¦‚æœä½ è¿™æ ·ä½¿ç”¨ï¼š

```cpp
HasPtr a("hello");
HasPtr b = a;  // è°ƒç”¨åˆæˆæ‹·è´æ„é€ å‡½æ•°
```

* ç°åœ¨ `a.ps` å’Œ `b.ps` éƒ½æŒ‡å‘åŒä¸€å—å†…å­˜ã€‚
* å½“ `a` è¢«é”€æ¯æ—¶ï¼Œ`delete ps` ä¼šé‡Šæ”¾è¿™å—å†…å­˜ã€‚
* å½“ `b` è¢«é”€æ¯æ—¶ï¼Œåˆä¼š `delete ps` â†’ å¯¼è‡´é‡å¤é‡Šæ”¾ï¼ˆdouble freeï¼‰ã€‚

Rule of Three ç¬¬ä¸€æ¡ï¼š"Classes That Need Destructors Need Copy and Assignment"ã€‚
å¦‚æœç±»è‡ªå·±ç®¡ç†èµ„æºï¼ˆå¦‚ `new/delete`ï¼‰ï¼Œå¿…é¡»è‡ªå·±å†™ copy constructorï¼ˆå®ç°æ·±æ‹·è´ï¼‰å’Œ copy assignment operatorã€‚


### 2. Classes That Need Copy Need Assignment, and Vice Versa

å¦‚æœä¸€ä¸ªç±»éœ€è¦æ‹·è´æ„é€ å‡½æ•°ï¼Œå®ƒå‡ ä¹ä¹Ÿä¸€å®šéœ€è¦æ‹·è´èµ‹å€¼è¿ç®—ç¬¦ã€‚åä¹‹äº¦ç„¶ã€‚

ä½†æ˜¯éœ€è¦æ‹·è´æ„é€ æˆ–æ‹·è´èµ‹å€¼ï¼Œä¸ä¸€å®šéœ€è¦ææ„å‡½æ•°ã€‚

### 3. Deleted å‡½æ•°

ç¼–è¯‘å™¨ä¼šä¸ºä½ è‡ªåŠ¨ç”Ÿæˆ copy-control æˆå‘˜ï¼Œä½†å¦‚æœç±»ä¸­æŸä¸ªæˆå‘˜æ— æ³•è¢«æ‹·è´/èµ‹å€¼/é”€æ¯ï¼Œç¼–è¯‘å™¨å°±ä¼šæŠŠå¯¹åº”çš„å‡½æ•°æ ‡è®°ä¸º = deletedï¼Œæ¥é¿å…äº§ç”Ÿå±é™©å¯¹è±¡ã€‚

Deleted çš„åŸå› é€šå¸¸æ˜¯ï¼š

- æˆå‘˜ä¸å¯è®¿é—®ï¼ˆprivate destructorï¼‰
- æˆå‘˜æœ‰ deleted å‡½æ•°ï¼ˆdeleted copy ctor / deleted operator=ï¼‰
- const æˆ– reference æˆå‘˜å¯¼è‡´é»˜è®¤èµ‹å€¼ä¸å¯å®ç°

**æ€»ç»“**ï¼šå¦‚æœç±»éœ€è¦ç”¨æˆ·å®šä¹‰çš„ææ„å‡½æ•°ã€æ‹·è´æ„é€ å‡½æ•°æˆ–æ‹·è´èµ‹å€¼è¿ç®—ç¬¦ï¼Œå‡ ä¹è‚¯å®šéœ€è¦ä¸‰è€…éƒ½å®šä¹‰ã€‚


## ğŸš§ Copy Control and Resource Management
