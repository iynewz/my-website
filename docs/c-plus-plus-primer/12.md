---
icon: lucide/book-open
tags:
  - C++
  - Dynamic Memory
  - Ch12
---

# 12. Dynamic Memory 基础

动态内存（Dynamic Memory）指程序 **运行时** 按需申请和释放的内存。这类内存位于 **heap（堆）/ free store**，与静态内存和栈内存不同，可以让我们 **自行控制对象的生命周期** 。

## 为什么要学 Dynamic Memory？

动态内存在现代 C++ 中非常重要，主要原因包括：

- **输入大小不确定**：数据规模需运行时决定，如 `vector` 就依赖动态内存扩容。
- **需要灵活的大型数据结构**：链表、树、图等节点必须动态生成。
- **堆空间远大于栈**：避免栈溢出风险。
- **现代 C++ 的基础能力**：容器、智能指针（`shared_ptr` / `unique_ptr`）都依赖动态内存。

而且手动管理内存容易出错：  

- **释放太早 → 悬空指针**  
- **忘记释放 → 内存泄漏（memory leak）**  

???+ note "建议结合 CSAPP 9.11 阅读"

    CSAPP 9.11 *Common Memory-Related Bugs in C Programs* 介绍了多种和内存有关的常见错误
    


## 动态内存的三个典型用途

1. **不知道需要多少对象**  
   类似 `vector` 的容量是运行时决定的。

2. **不知道对象的实际类型**  
   第 15 章讲多态时会进一步介绍。

3. **多个对象共享数据**  
   `shared_ptr` 的用途——共享所有权。


## 堆（heap / free store）是什么？

除了静态内存和栈内存外，每个程序还有一片可供使用的内存区域，称为 free store 或堆 heap。程序运行时可从 **free store / heap** 申请内存：

- 用于动态分配对象
- 用完后必须显式销毁（或让智能指针自动管理）

本章的重点就是理解：  
**什么时候需要从堆上创建对象，以及如何用智能指针安全地管理它们。**

## `shared_ptr` — 共享所有权的智能指针

智能指针定义在 `<memory>` 头文件中，是手动 `new`/`delete` 的安全替代品。

示例：

```cpp
shared_ptr<string> p1;                      // 可以指向 string
shared_ptr<int> p3 = make_shared<int>(42); // 创建一个值为 42 的 int
```